using System;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;

namespace Malware.MDKDefaultModules.Composer.Default
{
    /// <summary>
    /// The generator used to produce the final script after all the rest of the build operation is complete.
    /// </summary>
    public class ScriptGenerator
    {
        static readonly string[] NewLines = {"\r\n", "\n"};

        /// <summary>
        /// Generates a final script of the given document. This document has been generated by the build process and
        /// contains the entire script in syntax tree form.
        /// </summary>
        /// <param name="document"></param>
        /// <returns></returns>
        public async Task<string> Generate(Document document)
        {
            var analyzer = new DocumentAnalyzer();
            var result = await analyzer.Analyze(document);
            var buffer = new StringBuilder();

            var programContent =
                DeIndent(
                    string.Join("\n", result.Parts.OfType<ProgramScriptPart>().Select(p => p.GenerateContent()))
                        .Split(NewLines, StringSplitOptions.None)
                ).Trim();
            buffer.Append(programContent);
            buffer.Append("\n");

            var extensionContent =
                DeIndent(
                    string.Join("\n", result.Parts.OfType<ExtensionScriptPart>().Select(p => p.GenerateContent()))
                        .Split(NewLines, StringSplitOptions.None)
                ).Trim();

            if (!string.IsNullOrWhiteSpace(extensionContent))
            {
                // Extension classes are made possible by forcefully ending Space Engineer's wrapping Program class
                // and removing the final ending brace of the last extension class to let Space Engineers close it 
                // for itself.

                // Close off the Program class
                buffer.Append("}\n");
                buffer.Append(extensionContent);
                // Remove the ending brace of the last extension class
                var index = FindEndBrace(buffer);
                if (index >= 0)
                    buffer.Length = index;
            }

            return buffer.ToString();
        }

        int FindEndBrace(StringBuilder buffer)
        {
            for (var i = buffer.Length - 1; i >= 0; i--)
            {
                var ch = buffer[i];
                if (char.IsWhiteSpace(ch) || ch != '}')
                    continue;
                return i;
            }
            return -1;
        }

        string DeIndent(string[] programPartLines)
        {
            var lines = programPartLines.ToList();
            // Remove trailing empty lines
            while (lines.Count > 0 && string.IsNullOrWhiteSpace(lines[lines.Count - 1]))
                lines.RemoveAt(lines.Count - 1);

            // Remove leading empty lines
            while (lines.Count > 0 && string.IsNullOrWhiteSpace(lines[0]))
                lines.RemoveAt(0);

            // Detect indentation
            var indent = int.MaxValue;
            for (var i = 0; i < lines.Count; i++)
            {
                var line = lines[i];
                if (string.IsNullOrWhiteSpace(line))
                {
                    lines[i] = "";
                    continue;
                }

                var match = Regex.Match(line, @"^\s+");
                if (match.Success)
                {
                    var tabLength = TabLengthOfValue(match.Value);
                    if (tabLength > 0 && tabLength < indent)
                        indent = tabLength;
                }
            }
            if (indent == int.MaxValue)
            {
                return string.Join("\r\n", lines);
            }

            // Remove indentation
            for (var i = 0; i < lines.Count; i++)
            {
                var line = lines[i];
                if (line.Length == 0)
                    continue;
                var tabs = 0;
                for (var j = 0; j < indent; j++)
                {
                    var ch = line[j];
                    if (ch == '\t')
                    {
                        tabs += 4;
                    }
                    else if (ch == ' ')
                    {
                        tabs++;
                    }
                    else
                    {
                        lines[i] = line.TrimStart();
                        break;
                    }
                    if (tabs >= indent)
                    {
                        lines[i] = line.Substring(j + 1);
                        break;
                    }
                }
            }
            return string.Join("\r\n", lines);
        }

        int TabLengthOfValue(string value)
        {
            return value.Select(c => c == '\t' ? 4 : 1).Sum();
        }
    }
}
